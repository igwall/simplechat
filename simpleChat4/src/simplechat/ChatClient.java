package simplechat;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import com.lloseng.ocsf.client.*;import common.*;import java.io.*;import java.util.Observable;import java.util.Observer;/** * This class overrides some of the methods defined in the abstract * superclass in order to give more functionality to the client. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave; * @author Fran&ccedil;ois B&eacute;langer * @version July 2000 */public class ChatClient implements Observer{  //Instance variables **********************************************    /**   * The interface type variable.  It allows the implementation of    * the display method in the client.   */  private ChatIF clientUI;    /**   * Instance variable used to store the client username.   */  private String username;    /**   * Observable client instance used to call client methods.   */  private ObservableClient observable;    //Constructors ****************************************************    /**   * Constructs an instance of the chat client.   *   * @param host The server to connect to.   * @param port The port number to connect on.   * @param clientUI The interface type variable.   */    public ChatClient(String host, int port, ChatIF clientUI)     throws IOException   {    this.clientUI = clientUI;        observable = new ObservableClient(host, port);    observable.addObserver(this);    observable.openConnection();  }    //Instance methods ************************************************    /**   * Set the the username of the client.   *    * @param username The new user name.   */  public void setUsername(String username)  {  	this.username = username;  }    /**   * Get the username of the client.   *    * @return The username of the client.   */  public String getUsername()  {  	return username;  }    @Override  public void update(Observable o, Object arg)  {  	if (arg instanceof Exception) {      // Handle exception  		  	} else {  		String msg = (String) arg;  		if (msg.equals(ObservableClient.CONNECTION_ESTABLISHED)) {  			clientUI.display("Connected to the server.");  		} else if (msg.equals(ObservableClient.CONNECTION_CLOSED)) {  			clientUI.display("Disconnected from the server.");  		} else {  			handleMessageFromServer(arg);  		}  	}  }      /**   * This method handles all data that comes in from the server.   *   * @param msg The message from the server.   */  public void handleMessageFromServer(Object msg)   {  	String message = (String) msg;  	String[] command = ChatIF.parseCommand(message);  	if (command == null) {  		clientUI.display(msg.toString());  	} else {  		switch (command[0]) {  		case "logoff":  			try {  	  		observable.closeConnection();  	  	} catch(IOException e) {}  			break;  		}  	}  }  /**   * This method handles all data coming from the UI               *   * @param message The message from the UI.       */  public void handleMessageFromClientUI(String message)  {    try    {    	String[] command = ChatIF.parseCommand(message);    	if (command == null) {    		observable.sendToServer(message);    	} else {    		handleClientCommand(command, message);    	}    }    catch(IOException e)    {      clientUI.display("Could not send message to server. Terminating client.");      quit();    }  }    /**   * Handle commands from the client.   * @param command The command to handle.   */  public void handleClientCommand(String[] command, String message)  {  	switch (command[0])  	{  	case "quit":  		try {				observable.sendToServer("#logoff");			} catch (IOException e1) { }  		quit();  		break;  	case "logoff":  		try {  			observable.sendToServer("#logoff");  			observable.closeConnection();  		} catch(IOException e) { }  		break;  	case "sethost":  		if (command.length < 2) {  			clientUI.display("No host provided. The command is #sethost <host>.");  		} else if (observable.isConnected()) {  			clientUI.display("Can't change the host while connected to a server. Please first use #logoff.");  		} else {  			observable.setHost(command[1]);  		}  		break;  	case "setport":  		if (command.length < 2) {  			clientUI.display("No port provided. The command is #setport <port>.");  		} else if (observable.isConnected()) {  			clientUI.display("Can't change the port while connected to a server. Please first use #logoff.");  		} else {  			try {  				int port = Integer.parseInt(command[1]);  				observable.setPort(port);  			} catch (NumberFormatException e) {  				clientUI.display("Invalid port number.");  			}  		}  		break;  	case "login":  		if (command.length < 2) {  			clientUI.display("No login provided. The command is #login <username>.");  		} else if (observable.isConnected() && getUsername() != null) {  			clientUI.display("You are already connected to a server. Please first use #logoff.");  		} else {  			setUsername(command[1]);  			try {  				observable.openConnection();  				observable.sendToServer(message);				} catch (IOException e) { }  		}  		break;  	case "gethost":  		clientUI.display(observable.getHost());  		break;  	case "getport":  		clientUI.display(Integer.toString(observable.getPort()));  		break;  	default:  		clientUI.display("Not a valid command.");  		break;  	}  }    /**   * This method terminates the client.   */  public void quit()  {    try    {    	observable.closeConnection();    }    catch(IOException e) {}    System.exit(0);  }}//End of simplechat.ChatClient class