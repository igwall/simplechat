package simplechat;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.Observable;import java.util.Observer;import com.lloseng.ocsf.server.*;import common.ChatIF;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer /*extends AbstractServer*/ implements Observer {  //Class variables *************************************************  	/**	 * Instance of the server UI.	 */  private ChatIF serverUI;    /**   * Observable server used to call server methods.   */  ObservableOriginatorServer observer;    //Constructors ****************************************************    /**   * Constructs an instance of the echo server.   *   * @param port The port number to connect on.   */  public EchoServer(int port, ChatIF serverUI)   {  	observer = new ObservableOriginatorServer(port);  	observer.addObserver(this);    this.serverUI = serverUI;  }  //Instance methods ************************************************    /**   * @throws IOException    * Listen for new connections.   */  public void listen() throws IOException  {	observer.listen();  }    @Override  public void update(Observable obs, Object arg)  {	  /* Handle observable server message */	  if (arg instanceof Exception) {	  } else {		  OriginatorMessage originatorMessage = (OriginatorMessage) arg;		  Object objectMessage = originatorMessage.getMessage();		  ConnectionToClient client = originatorMessage.getOriginator();		  String message = (String) objectMessage;		  switch (message) {			  case ObservableServer.CLIENT_CONNECTED:				  serverUI.display("Client connected.");				  break;			  case ObservableServer.CLIENT_DISCONNECTED:				  serverUI.display("Client disconnected.");				  break;			  case ObservableServer.CLIENT_EXCEPTION:				  serverUI.display("Client exception.");				  break;			  case ObservableServer.LISTENING_EXCEPTION:				  serverUI.display("Listening exception.");				  break;			  case ObservableServer.SERVER_CLOSED:				  serverUI.display("Server closed.");				  break;			  case ObservableServer.SERVER_STARTED:				  serverUI.display("Server started.");				  break;			  case ObservableServer.SERVER_STOPPED:				  serverUI.display("Server closed.");				  break;			  default:				  handleMessageFromClient(objectMessage, client);		  }	  }  }    /**   * This method handles any messages received from the client.   *   * @param msg The message received from the client.   * @param client The connection from which the message originated.   */  public void handleMessageFromClient    (Object msg, ConnectionToClient client)  {    String message = (String) msg;     String[] command = ChatIF.parseCommand(message);    String username = (String) client.getInfo("username");        if (command == null)    {    	// If it's not a command    	if (username == null) {    		try {					client.sendToClient("You should first login with #login <username>.");					client.sendToClient("#logoff");					client.close();				} catch (IOException e) { }    	} else {    	  serverUI.display(username + ">" + msg);    	  observer.sendToAllClients(username + "> " + msg);    	}    } else     {    	switch (command[0])    	{    	case "logoff":    		try {					client.close();				} catch (IOException e1) { }    		break;    	case "login":    		if (username == null && command.length >= 2) {    			client.setInfo("username", command[1]);    		} else {    			try {						client.sendToClient("You can't change your username once connected.");					} catch (IOException e) { }    		}    		break;    	}    }  }  /**   * This method handles any messages received from the server UI.   *    * @param message The message to handle.   */	public void handleMessageFromServerUI(String message)	{		String[] command = ChatIF.parseCommand(message);		if (command == null) {			sendMessage(message);		} else {			handleCommand(command);		}	}		/**	 * The server console send a message to all the clients. 	 */	public void sendMessage(String message)	{		observer.sendToAllClients("Server MSG> " + message);	}		/**	 * Handle command from the server.	 * 	 * @param command The command the handle.	 */	public void handleCommand(String[] command)	{		switch (command[0])  	{  	case "quit":  		observer.sendToAllClients("#logoff");  		try {  			observer.close();			} catch (IOException e1) { }  		System.exit(0);  		break;  	case "stop":  		observer.stopListening();  		break;  	case "close":  		observer.stopListening();  		observer.sendToAllClients("#logoff");  		try {  			observer.close();			} catch (IOException e) { }  		break;  	case "setport":  		if (command.length < 2) {  			serverUI.display("No port provided. The command is #setport <port>.");  		} else if (observer.isListening()) {  			serverUI.display("Can't change the port while listening. Please first use #close.");  		} else {  			try {  				int port = Integer.parseInt(command[1]);  				observer.setPort(port);  			} catch (NumberFormatException e) {  				serverUI.display("Invalid port number.");  			}  		}  		break;  	case "getport":  		serverUI.display(Integer.toString(observer.getPort()));  		break;  	case "start":  		if (observer.isListening()) {  			serverUI.display("Can't change the port while listening. Please first use #close.");  		} else {  			try {  				observer.listen();				} catch (IOException e) { }  		}  		break;  	default:  		serverUI.display("Not a valid command.");  		break;  	}	}      /**   * This method overrides the one in the superclass.  Called   * when the server starts listening for connections.   */  protected void serverStarted()  {    serverUI.display("Server listening for connections on port " + observer.getPort());  }    /**   * This method overrides the one in the superclass.  Called   * when the server stops listening for connections.   */  protected void serverStopped()  {  	serverUI.display("Server has stopped listening for connections.");  }}//End of simplechat.EchoServer class